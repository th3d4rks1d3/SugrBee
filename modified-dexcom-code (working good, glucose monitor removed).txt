/*
 * Optimized Dexcom Glucose Monitor
 * 
 * A refactored, optimized version of the Dexcom Monitor code
 * for ESP32 with touchscreen display with improved touch handling
 * and screen transitions.
 */

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiManager.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <TFT_eSPI.h>
#include <time.h>
#include <SPIFFS.h>
#include <FS.h>
#include <WiFiClientSecure.h>
#include <PNGdec.h>
#include <XPT2046_Touchscreen.h>
#include <SPI.h>

// Global variable declaration - this needs to be before any function uses it
bool shouldResetSettings = false; // Flag for settings reset

// Constants for configuration
#define MAX_GLUCOSE_HISTORY 24  // Store last 24 readings (approx. 2 hours)
#define UPDATE_INTERVAL 300000   // 5 minutes in milliseconds
#define TOUCH_DEBOUNCE 500       // 500ms debounce period
#define RESET_PIN 0              // GPIO0 for reset button
#define MAX_IMAGE_WBYTES 240     // Width for PNG buffer
#define PNG_BUFFER_SIZE 6000     // PNG decoder buffer size

// Touchscreen pins - adjust based on your wiring
#define XPT2046_IRQ 36   // T_IRQ
#define XPT2046_MOSI 32  // T_DIN
#define XPT2046_MISO 39  // T_OUT
#define XPT2046_CLK 25   // T_CLK
#define XPT2046_CS 33    // T_CS

// Keyboard configuration
#define KEYBOARD_ROWS 4
#define KEYBOARD_COLS 10
#define KEY_WIDTH 24
#define KEY_HEIGHT 30
#define KEYBOARD_Y 60

// Define colors for different BG ranges
#define COLOR_BG_LOW TFT_BLUE
#define COLOR_BG_NORMAL TFT_GREEN
#define COLOR_BG_HIGH TFT_YELLOW
#define COLOR_BG_VERY_HIGH TFT_RED

// Dexcom API URLs
#define US_AUTHENTICATE_URL "https://share2.dexcom.com/ShareWebServices/Services/General/AuthenticatePublisherAccount"
#define US_LOGIN_URL "https://share2.dexcom.com/ShareWebServices/Services/General/LoginPublisherAccountById"
#define US_GLUCOSE_URL "https://share2.dexcom.com/ShareWebServices/Services/Publisher/ReadPublisherLatestGlucoseValues"
#define EU_AUTHENTICATE_URL "https://shareous1.dexcom.com/ShareWebServices/Services/General/AuthenticatePublisherAccount"
#define EU_LOGIN_URL "https://shareous1.dexcom.com/ShareWebServices/Services/General/LoginPublisherAccountById"
#define EU_GLUCOSE_URL "https://shareous1.dexcom.com/ShareWebServices/Services/Publisher/ReadPublisherLatestGlucoseValues"
#define DEFAULT_APP_ID "d8665ade-9673-4e27-9ff6-92db4ce13d13"

// Debug mode for touch
#define DEBUG_TOUCH true  // Set to true to enable touch coordinate debugging

// Keyboard layout
const char keyboardLayout[KEYBOARD_ROWS][KEYBOARD_COLS+1] = {
  "QWERTYUIOP",
  "ASDFGHJKL ",
  "ZXCVBNM   "
};

// PNG file names for different trend arrows
const char* TREND_PNG_FILES[] = {
    "/none.png",             // 0 - None (no arrow)
    "/doubleup.png",         // 1 - DoubleUp
    "/up.png",               // 2 - SingleUp
    "/diagonalup.png",       // 3 - FortyFiveUp
    "/even.png",             // 4 - Flat
    "/diagonaldown.png",     // 5 - FortyFiveDown
    "/down.png",             // 6 - SingleDown
    "/doubledown.png",       // 7 - DoubleDown
    "/question.png",         // 8 - NotComputable
    "/dash.png"              // 9 - RateOutOfRange
};

// Trend direction mapping
const char *DEXCOM_TREND_DIRECTIONS[] = {
    "None",          // 0 - Unconfirmed
    "DoubleUp",      // 1 - Rapidly rising
    "SingleUp",      // 2 - Rising
    "FortyFiveUp",   // 3 - Slowly rising
    "Flat",          // 4 - Stable
    "FortyFiveDown", // 5 - Slowly falling
    "SingleDown",    // 6 - Falling
    "DoubleDown",    // 7 - Rapidly falling
    "NotComputable", // 8 - Unconfirmed
    "RateOutOfRange" // 9 - Unconfirmed
};

// TFT Display setup
TFT_eSPI tft;

// PNG decoder
PNG png;
uint8_t pngBuffer[PNG_BUFFER_SIZE];

// Touchscreen setup
SPIClass touchscreenSPI(VSPI);
XPT2046_Touchscreen touchscreen(XPT2046_CS, XPT2046_IRQ);

// Structure for glucose readings
struct GlucoseReading {
    float value;  // Glucose value (mg/dL)
    unsigned long timestamp;  // Unix timestamp
};

// PNG drawing parameters
struct PNG_DRAW_PARAMS {
    int16_t x;      // X offset on screen
    int16_t y;      // Y offset on screen
    uint16_t color; // For color tinting if needed
};

// Settings class to manage configuration
class Settings {
public:
    char dexcomUsername[50] = "";
    char dexcomPassword[50] = "";
    bool useEUServer = false;
    char customTitle[30] = "Glucose Monitor"; // Default title
    
    void load() {
        if (!SPIFFS.exists("/settings.json")) {
            Serial.println("Settings file not found");
            return;
        }
        
        File file = SPIFFS.open("/settings.json", FILE_READ);
        if (!file) {
            Serial.println("Failed to open settings file");
            return;
        }
        
        DynamicJsonDocument doc(512);
        DeserializationError error = deserializeJson(doc, file);
        
        if (error) {
            Serial.println("Failed to parse settings file");
        } else {
            strncpy(dexcomUsername, doc["dexcomUsername"] | "", sizeof(dexcomUsername) - 1);
            dexcomUsername[sizeof(dexcomUsername) - 1] = '\0';
            
            strncpy(dexcomPassword, doc["dexcomPassword"] | "", sizeof(dexcomPassword) - 1);
            dexcomPassword[sizeof(dexcomPassword) - 1] = '\0';
            
            useEUServer = doc["useEUServer"] | false;
            
            if (doc.containsKey("customTitle")) {
                strncpy(customTitle, doc["customTitle"] | "Glucose Monitor", sizeof(customTitle) - 1);
                customTitle[sizeof(customTitle) - 1] = '\0';
            }
            
            Serial.println("Settings loaded");
            Serial.print("Username length: ");
            Serial.println(strlen(dexcomUsername));
            Serial.print("Password length: ");
            Serial.println(strlen(dexcomPassword));
            Serial.print("Using EU Server: ");
            Serial.println(useEUServer ? "Yes" : "No");
            Serial.print("Custom Title: ");
            Serial.println(customTitle);
        }
        
        file.close();
    }

    void save() {
        File file = SPIFFS.open("/settings.json", FILE_WRITE);
        if (!file) {
            Serial.println("Failed to open settings file for writing");
            return;
        }
        
        DynamicJsonDocument doc(512);
        doc["dexcomUsername"] = dexcomUsername;
        doc["dexcomPassword"] = dexcomPassword;
        doc["useEUServer"] = useEUServer;
        doc["customTitle"] = customTitle;
        
        if (serializeJson(doc, file) == 0) {
            Serial.println("Failed to write settings");
        } else {
            Serial.println("Settings saved successfully");
        }
        
        file.close();
    }

    void reset() {
        dexcomUsername[0] = '\0';
        dexcomPassword[0] = '\0';
        useEUServer = false;
        strncpy(customTitle, "Glucose Monitor", sizeof(customTitle) - 1);
        customTitle[sizeof(customTitle) - 1] = '\0';
        save();
    }
};

// Global instance
Settings settings;

// Dexcom API client class
class DexcomClient {
private:
    char accountId[100] = "";
    char sessionId[100] = "";
    String authenticateUrl;
    String loginUrl;
    String glucoseUrl;
    const char* applicationId;
    
public:
    DexcomClient() : applicationId(DEFAULT_APP_ID) {}
    
    void init() {
        // Set URLs based on server selection
        if (settings.useEUServer) {
            authenticateUrl = EU_AUTHENTICATE_URL;
            loginUrl = EU_LOGIN_URL;
            glucoseUrl = EU_GLUCOSE_URL;
            Serial.println("Using EU Dexcom servers");
        } else {
            authenticateUrl = US_AUTHENTICATE_URL;
            loginUrl = US_LOGIN_URL;
            glucoseUrl = US_GLUCOSE_URL;
            Serial.println("Using US Dexcom servers");
        }
    }
    
    bool authenticate() {
        if (WiFi.status() != WL_CONNECTED) {
            return false;
        }
        
        // Check for valid credentials
        if (strlen(settings.dexcomUsername) == 0 || strlen(settings.dexcomPassword) == 0) {
            Serial.println("Error: Dexcom credentials are empty!");
            tft.fillScreen(TFT_BLACK);
            tft.setTextSize(2);
            tft.setTextColor(TFT_RED);
            tft.setCursor(20, 60);
            tft.println("Missing Dexcom credentials");
            tft.setCursor(20, 90);
            tft.println("Reset & reconfigure");
            return false;
        }
        
        WiFiClientSecure client;
        HTTPClient http;
        Serial.println("Authenticating to Dexcom (step 1)...");
        
        tft.fillScreen(TFT_BLACK);
        tft.setTextSize(2);
        tft.setCursor(20, 60);
        tft.println("Connecting to Dexcom...");
        
        // Skip certificate validation
        client.setInsecure();
        
        if (!http.begin(client, authenticateUrl.c_str())) {
            Serial.println("Failed to set up HTTPS connection");
            return false;
        }
        
        // Add headers that mimic a browser
        http.addHeader("Content-Type", "application/json");
        http.addHeader("User-Agent", "Dexcom Share/3.0.2.11 CFNetwork/711.2.23 Darwin/14.0.0");
        http.addHeader("Accept", "application/json");
        http.setTimeout(15000);
        
        // Create authentication payload
        char authenticatePayload[256];
        snprintf(authenticatePayload, sizeof(authenticatePayload), 
                 "{\"accountName\":\"%s\",\"password\":\"%s\",\"applicationId\":\"%s\"}", 
                 settings.dexcomUsername, settings.dexcomPassword, applicationId);
        
        Serial.println("Sending authentication request...");
        
        int httpResponseCode = http.POST(authenticatePayload);
        String response = http.getString();
        
        if (httpResponseCode == HTTP_CODE_OK) {
            // Remove quotes from account ID
            response.replace("\"", "");
            strncpy(accountId, response.c_str(), sizeof(accountId) - 1);
            accountId[sizeof(accountId) - 1] = '\0';
            
            Serial.print("Account ID: ");
            Serial.println(accountId);
            
            http.end();
            return true;
        } else {
            Serial.print("Error on authentication: ");
            Serial.println(httpResponseCode);
            Serial.print("Response: ");
            Serial.println(response);
            
            // Display detailed error
            tft.fillScreen(TFT_BLACK);
            tft.setCursor(20, 30);
            tft.println("Auth Error: " + String(httpResponseCode));
            
            tft.setTextSize(1);
            tft.setCursor(20, 60);
            tft.println("Response: " + response.substring(0, 120));
            
            tft.setCursor(20, 80);
            if (httpResponseCode == 500) {
                tft.println("Server error. Could be:");
                tft.setCursor(20, 90);
                tft.println("- Incorrect application ID");
                tft.setCursor(20, 100);
                tft.println("- Account/password issue");
                tft.setCursor(20, 110);
                tft.println("- Dexcom server problem");
            } else if (httpResponseCode == -1) {
                tft.println("Connection failed");
                tft.setCursor(20, 90);
                tft.println("Check credentials & internet");
            } else {
                tft.println(http.errorToString(httpResponseCode));
            }
            
            accountId[0] = '\0'; // Reset on failure
            http.end();
            delay(5000);
            return false;
        }
    }
    
    bool authenticateWithRetry() {
        for (int attempt = 0; attempt < 3; attempt++) {
            Serial.print("Authentication attempt #");
            Serial.println(attempt + 1);
            
            if (authenticate()) {
                return true;
            }
            
            Serial.println("Authentication failed, retrying...");
            delay(5000 * (attempt + 1)); // Exponential backoff
        }
        
        return false;
    }
    
    bool login() {
        if (WiFi.status() != WL_CONNECTED || strlen(accountId) == 0) {
            return false;
        }
        
        WiFiClientSecure client;
        HTTPClient http;
        Serial.println("Logging in to Dexcom (step 2)...");
        
        // Skip certificate validation
        client.setInsecure();
        
        if (!http.begin(client, loginUrl.c_str())) {
            Serial.println("Failed to set up HTTPS connection");
            return false;
        }
        
        http.addHeader("Content-Type", "application/json");
        http.addHeader("User-Agent", "Dexcom Share/3.0.2.11 CFNetwork/711.2.23 Darwin/14.0.0");
        http.addHeader("Accept", "application/json");
        http.setTimeout(15000);
        
        // Create login payload
        char loginPayload[256];
        snprintf(loginPayload, sizeof(loginPayload), 
                 "{\"accountId\":\"%s\",\"password\":\"%s\",\"applicationId\":\"%s\"}", 
                 accountId, settings.dexcomPassword, applicationId);
        
        Serial.println("Sending login request...");
        
        int httpResponseCode = http.POST(loginPayload);
        String response = http.getString();
        
        if (httpResponseCode == HTTP_CODE_OK) {
            // Remove quotes from session ID
            response.replace("\"", "");
            strncpy(sessionId, response.c_str(), sizeof(sessionId) - 1);
            sessionId[sizeof(sessionId) - 1] = '\0';
            
            Serial.print("Session ID: ");
            Serial.println(sessionId);
            
            tft.setCursor(20, 90);
            tft.println("Login successful!");
            
            http.end();
            return true;
        } else {
            Serial.print("Error on login: ");
            Serial.println(httpResponseCode);
            Serial.print("Response: ");
            Serial.println(response);
            
            // Display error
            tft.fillScreen(TFT_BLACK);
            tft.setCursor(20, 60);
            tft.println("Login Error: " + String(httpResponseCode));
            tft.setCursor(20, 90);
            tft.setTextSize(1);
            tft.println("Response: " + response.substring(0, 60));
            
            sessionId[0] = '\0'; // Reset on failure
            http.end();
            return false;
        }
    }
    
    time_t extractUnixTime(const char* rawTime) {
        String rawTimeStr(rawTime);
        if (rawTimeStr.startsWith("Date(")) {
            int startPos = 5;
            int dashPos = rawTimeStr.indexOf('-', startPos);
            if (dashPos == -1)
                dashPos = rawTimeStr.indexOf('+', startPos);
            
            if (dashPos > startPos) {
                String timestampStr = rawTimeStr.substring(startPos, dashPos);
                return strtoull(timestampStr.c_str(), NULL, 10) / 1000;
            }
        }
        return 0;
    }
    
    bool formatTimestamp(const char* rawTime, char* formattedTime, size_t maxSize) {
        if (maxSize < 6) {
            return false;
        }
        
        if (strncmp(rawTime, "Date(", 5) == 0) {
            const char* startPos = rawTime + 5;
            const char* dashPos = strchr(startPos, '-');
            if (dashPos == NULL) {
                dashPos = strchr(startPos, '+');
            }
            
            if (dashPos && dashPos > startPos) {
                const char* endPos = strchr(dashPos, ')');
                
                if (endPos && endPos > dashPos) {
                    // Extract timestamp
                    char timestampStr[24];
                    size_t timestampLen = dashPos - startPos;
                    if (timestampLen >= sizeof(timestampStr)) {
                        timestampLen = sizeof(timestampStr) - 1;
                    }
                    strncpy(timestampStr, startPos, timestampLen);
                    timestampStr[timestampLen] = '\0';
                    
                    // Extract timezone offset
                    char tzOffsetStr[8];
                    size_t tzOffsetLen = endPos - dashPos - 1;
                    if (tzOffsetLen >= sizeof(tzOffsetStr)) {
                        tzOffsetLen = sizeof(tzOffsetStr) - 1;
                    }
                    strncpy(tzOffsetStr, dashPos + 1, tzOffsetLen);
                    tzOffsetStr[tzOffsetLen] = '\0';
                    
                    // Convert to timestamp
                    unsigned long long timestamp;
                    char* endptr;
                    timestamp = strtoull(timestampStr, &endptr, 10);
                    
                    if (*endptr != '\0') {
                        Serial.println("Error parsing timestamp");
                        return false;
                    }
                    
                    // Parse timestamp and format
                    int tzOffset = atoi(tzOffsetStr);
                    int tzHours = tzOffset / 100;
                    int tzMinutes = tzOffset % 100;
                    
                    time_t seconds = timestamp / 1000;
                    seconds -= (tzHours * 3600 + tzMinutes * 60);
                    struct tm timeInfo;
                    gmtime_r(&seconds, &timeInfo);
                    
                    // Format time
                    snprintf(formattedTime, maxSize, "%02d:%02d", timeInfo.tm_hour, timeInfo.tm_min);
                    return true;
                }
            }
        }
        
        strncpy(formattedTime, "N/A", maxSize - 1);
        formattedTime[maxSize - 1] = '\0';
        return false;
    }
    
    bool checkDiff(DynamicJsonDocument &doc) {
        if (doc.size() < 3)
            return false;

        // Extract timestamps
        time_t time0 = extractUnixTime(doc[0]["DT"].as<const char*>());
        time_t time1 = extractUnixTime(doc[1]["DT"].as<const char*>());
        
        // Return true if within 5 minutes
        return abs(time0 - time1) < 300;
    }
    
    bool fetchGlucoseData(float& current_glucose, float& previous_glucose, 
                          char* trend, char* timestamp, unsigned long& lastDexcomTime,
                          bool isOverdueCheck = false) {
        if (WiFi.status() != WL_CONNECTED || strlen(sessionId) == 0) {
            return false;
        }
        
        WiFiClientSecure client;
        HTTPClient http;
        
        // Only show message for regular checks
        if (!isOverdueCheck) {
            tft.fillScreen(TFT_BLACK);
            tft.setTextSize(2);
            tft.setCursor(20, 60);
            tft.println("Getting glucose data...");
        }
        
        // Skip certificate validation
        client.setInsecure();
        
        if (!http.begin(client, glucoseUrl.c_str())) {
            Serial.println("Failed to set up HTTPS connection");
            return false;
        }
        
        http.addHeader("Content-Type", "application/json");
        http.addHeader("User-Agent", "Dexcom Share/3.0.2.11 CFNetwork/711.2.23 Darwin/14.0.0");
        http.addHeader("Accept", "application/json");
        http.setTimeout(15000);
        
        // Payload for glucose data
        char fetchPayload[128];
        snprintf(fetchPayload, sizeof(fetchPayload), 
                 "{\"sessionId\":\"%s\",\"minutes\":1440,\"maxCount\":4}", 
                 sessionId);
        
        Serial.println("Getting glucose data...");
        
        int httpResponseCode = http.POST(fetchPayload);
        
        if (httpResponseCode == HTTP_CODE_OK) {
            String response = http.getString();
            
            // Check for session expiration
            if (response.indexOf("SessionNotValid") != -1) {
                Serial.println("Session expired! Re-authenticating...");
                
                sessionId[0] = '\0';
                accountId[0] = '\0';
                
                if (!isOverdueCheck) {
                    tft.fillScreen(TFT_BLACK);
                    tft.setCursor(20, 60);
                    tft.println("Session expired, retrying...");
                }
                
                if (authenticateWithRetry() && login()) {
                    return fetchGlucoseData(current_glucose, previous_glucose, trend, timestamp, lastDexcomTime, isOverdueCheck);
                }
                
                http.end();
                return false;
            }
            
            // Parse JSON response
            DynamicJsonDocument doc(4096);
            DeserializationError error = deserializeJson(doc, response);
            
            if (!error) {
                if (doc.size() >= 3) {
                    // Get current and previous readings
                    current_glucose = doc[0]["Value"];
                    
                    // Determine which previous reading to use for comparison
                    int diffIndex = checkDiff(doc) ? 2 : 1; 
                    previous_glucose = doc[diffIndex]["Value"];
                    
                    // Get trend direction
                    const char* trendValue = doc[0]["Trend"].as<const char*>();
                    strncpy(trend, trendValue, 19);
                    trend[19] = '\0';
                    
                    // Extract timestamp
                    String rawTime = doc[0]["DT"].as<String>();
                    Serial.print("Raw timestamp: ");
                    Serial.println(rawTime);
                    
                    // Parse Dexcom's timestamp format
                    if (strncmp(rawTime.c_str(), "Date(", 5) == 0) {
                        const char* startPos = rawTime.c_str() + 5;
                        const char* dashPos = strchr(startPos, '-');
                        if (dashPos == NULL) {
                            dashPos = strchr(startPos, '+');
                        }
                        
                        if (dashPos && dashPos > startPos) {
                            size_t timestampLen = dashPos - startPos;
                            char timestampStr[24];
                            strncpy(timestampStr, startPos, timestampLen);
                            timestampStr[timestampLen] = '\0';
                            
                            char* endptr;
                            lastDexcomTime = strtoull(timestampStr, &endptr, 10);
                        }
                    }
                    
                    // Format the timestamp for display
                    char formattedTime[10];
                    if (formatTimestamp(rawTime.c_str(), formattedTime, sizeof(formattedTime))) {
                        strncpy(timestamp, formattedTime, 9);
                        timestamp[9] = '\0';
                    } else {
                        strncpy(timestamp, "N/A", 9);
                    }
                    
                    Serial.printf("Glucose: %.0f mg/dL | Trend: %s | Change: %+0.1f | Time: %s\n",
                                current_glucose, trend, current_glucose - previous_glucose, timestamp);
                    
                    http.end();
                    return true;
                } else {
                    Serial.println("Not enough glucose data received");
                    
                    if (!isOverdueCheck) {
                        tft.fillScreen(TFT_BLACK);
                        tft.setCursor(20, 60);
                        tft.println("Not enough glucose data");
                        tft.setCursor(20, 90);
                        tft.println("Readings available: " + String(doc.size()));
                    }
                }
            } else {
                Serial.print("JSON parsing error: ");
                Serial.println(error.c_str());
                
                if (!isOverdueCheck) {
                    tft.fillScreen(TFT_BLACK);
                    tft.setCursor(20, 60);
                    tft.println("JSON Error");
                    tft.setCursor(20, 90);
                    tft.setTextSize(1);
                    tft.println(error.c_str());
                }
            }
        } else if (httpResponseCode == 401) {
            // Session expired
            Serial.println("Session expired");
            sessionId[0] = '\0';
            accountId[0] = '\0';
            
            if (!isOverdueCheck) {
                tft.fillScreen(TFT_BLACK);
                tft.setCursor(20, 60);
                tft.println("Session expired, retrying...");
            }
            
            if (authenticateWithRetry() && login()) {
                return fetchGlucoseData(current_glucose, previous_glucose, trend, timestamp, lastDexcomTime, isOverdueCheck);
            }
        } else {
            Serial.print("Error on glucose request: ");
            Serial.println(httpResponseCode);
            
            if (!isOverdueCheck) {
                tft.fillScreen(TFT_BLACK);
                tft.setCursor(20, 60);
                tft.println("Glucose Error: " + String(httpResponseCode));
            }
        }
        
        http.end();
        return false;
    }

    bool fetchGlucoseHistory(GlucoseReading history[], int& count) {
        if (WiFi.status() != WL_CONNECTED || strlen(sessionId) == 0) {
            return false;
        }
        
        WiFiClientSecure client;
        HTTPClient http;
        
        // Skip certificate validation
        client.setInsecure();
        
        // Build URL
        char url[256];
        snprintf(url, sizeof(url), 
                "%s?sessionId=%s&minutes=1440&maxCount=%d", 
                glucoseUrl.c_str(), sessionId, MAX_GLUCOSE_HISTORY);
        
        if (!http.begin(client, url)) {
            Serial.println("Failed to set up HTTPS connection for history");
            return false;
        }
        
        http.addHeader("Content-Type", "application/json");
        http.addHeader("User-Agent", "Dexcom Share/3.0.2.11 CFNetwork/711.2.23 Darwin/14.0.0");
        http.addHeader("Accept", "application/json");
        http.setTimeout(15000);
        
        // Payload for history
        char fetchPayload[128];
        snprintf(fetchPayload, sizeof(fetchPayload), 
                "{\"sessionId\":\"%s\",\"minutes\":1440,\"maxCount\":%d}", 
                sessionId, MAX_GLUCOSE_HISTORY);
        
        Serial.println("Getting glucose history...");
        
        int httpResponseCode = http.POST(fetchPayload);
        
        if (httpResponseCode == HTTP_CODE_OK) {
            String response = http.getString();
            
            // Check for expired session
            if (response.indexOf("SessionNotValid") != -1) {
                Serial.println("Session expired when fetching history!");
                http.end();
                return false;
            }
            
            // Parse response
            DynamicJsonDocument doc(8192);
            DeserializationError error = deserializeJson(doc, response);
            
            if (!error) {
                // Reset history counter
                count = 0;
                
                // Process readings from oldest to newest
                int numReadings = doc.size();
                for (int i = numReadings - 1; i >= 0; i--) {
                    float glucose = doc[i]["Value"];
                    String rawTime = doc[i]["DT"].as<String>();
                    
                    unsigned long timestamp = 0;
                    
                    // Extract timestamp
                    if (strncmp(rawTime.c_str(), "Date(", 5) == 0) {
                        const char* startPos = rawTime.c_str() + 5;
                        const char* dashPos = strchr(startPos, '-');
                        if (dashPos == NULL) {
                            dashPos = strchr(startPos, '+');
                        }
                        
                        if (dashPos && dashPos > startPos) {
                            size_t timestampLen = dashPos - startPos;
                            char timestampStr[24];
                            strncpy(timestampStr, startPos, timestampLen);
                            timestampStr[timestampLen] = '\0';
                            
                            char* endptr;
                            timestamp = strtoull(timestampStr, &endptr, 10) / 1000;
                        }
                    }
                    
                    // Store reading
                    if (glucose > 0 && timestamp > 0) {
                        // Process oldest to newest
                        history[count].value = glucose;
                        history[count].timestamp = timestamp;
                        count++;
                        
                        if (count >= MAX_GLUCOSE_HISTORY) {
                            break;
                        }
                    }
                }
                
                Serial.printf("Stored %d glucose history readings\n", count);
                http.end();
                return true;
            } else {
                Serial.print("JSON parsing error in history: ");
                Serial.println(error.c_str());
            }
        } else {
            Serial.print("HTTP error when getting history: ");
            Serial.println(httpResponseCode);
        }
        
        http.end();
        return false;
    }
    
    const char* getSessionId() const {
        return sessionId;
    }
};

// Global instances
DexcomClient dexcomClient;
GlucoseReading glucoseHistory[MAX_GLUCOSE_HISTORY];
int glucoseHistoryCount = 0;

// Display manager class
class DisplayManager {
private:
    // Display state
    bool displayMgDL = true;
    bool displayingGraph = false;
    bool displayingKeyboard = false;
    bool displayingSettings = false;
    bool displayLargeDifferential = false;  // New state for enhanced differential display
    bool displayingConfirmation = false;    // State for confirmation dialog
    
    // Glucose data
    float current_glucose_mgdl = 0;
    float previous_glucose_mgdl = 0;
    float glucose_diff = 0;
    float glucose_mmol = 0;
    char trend[20] = "Flat";
    char timestamp[10] = "N/A";
    unsigned long lastDexcomReadingTime = 0;
    
    // Keyboard variables
    char inputBuffer[30] = "";
    int inputPosition = 0;
    
    // Touch areas
    int glucoseTouchX = 0;
    int glucoseTouchY = 0;
    int glucoseTouchWidth = 0;
    int glucoseTouchHeight = 0;
    int arrowTouchX = 0;
    int arrowTouchY = 0;
    int arrowTouchWidth = 100;
    int arrowTouchHeight = 50;
    int titleTouchX = 0;
    int titleTouchY = 0;
    int titleTouchWidth = 0;
    int titleTouchHeight = 30;
    int settingsTouchX = 0;
    int settingsTouchY = 0;
    int settingsTouchWidth = 40;
    int settingsTouchHeight = 40;
    int diffTouchX = 0;         // Touch area for differential display
    int diffTouchY = 0;
    int diffTouchWidth = 0;
    int diffTouchHeight = 0;
    
    // Reset Credentials button in settings
    int resetButtonX = 0;
    int resetButtonY = 0;
    int resetButtonWidth = 0;
    int resetButtonHeight = 0;
    
    // Confirmation dialog buttons
    int confirmYesX = 0;
    int confirmYesY = 0;
    int confirmYesWidth = 0;
    int confirmYesHeight = 0;
    int confirmNoX = 0;
    int confirmNoY = 0;
    int confirmNoWidth = 0;
    int confirmNoHeight = 0;
    
    // Display state tracking
    bool displayNeedsFullUpdate = true;
    bool displayNeedsTimeUpdate = true;
    char lastDisplayedTimeStr[30] = "";
    float lastDisplayedGlucose = -1;
    char lastDisplayedTrend[20] = "";
    bool lastDisplayedMgDL = true;
    
public:
    void init() {
        tft.fillScreen(TFT_BLACK);
        tft.setTextColor(TFT_WHITE, TFT_BLACK);
    }

    void showInitialScreen() {
        tft.setTextSize(2);
        tft.setCursor(20, 30);
        tft.println("Dexcom Glucose Monitor");
        tft.setCursor(20, 60);
        tft.println("Starting up...");
    }

    void showConfigMode() {
        tft.fillScreen(TFT_BLACK);
        tft.setTextSize(2);
        tft.setCursor(20, 30);
        tft.println("WiFi Setup Mode");
        tft.setCursor(20, 60);
        tft.println("Connect to WiFi network:");
        tft.setCursor(20, 90);
        tft.println("Dexcom-Monitor-Setup");
        tft.setCursor(20, 120);
        tft.println("Then open in browser:");
        tft.setCursor(20, 150);
        tft.println("192.168.4.1");
    }
    
    // Toggle the differential display mode
    void toggleDifferentialMode() {
        displayLargeDifferential = !displayLargeDifferential;
        displayNeedsFullUpdate = true;
    }
    
    // PNG drawing callback function
    static void pngDraw(PNGDRAW *pDraw) {
        // Create a buffer for a single line of image
        uint16_t lineBuffer[MAX_IMAGE_WBYTES];
        
        // Get the pointer to our custom parameters
        PNG_DRAW_PARAMS *params = (PNG_DRAW_PARAMS*)pDraw->pUser;
        
        // Convert to RGB565 for TFT
        png.getLineAsRGB565(pDraw, lineBuffer, PNG_RGB565_BIG_ENDIAN, 0xffffffff);
        
        // Calculate position
        int16_t x = params->x;
        int16_t y = params->y + pDraw->y;
        
        // Push to display
        tft.pushImage(x, y, pDraw->iWidth, 1, lineBuffer);
    }
    
    bool drawPNG(const char* filename, int16_t x, int16_t y) {
        Serial.printf("Loading PNG: %s\n", filename);
        
        // Open the file
        File pngFile = SPIFFS.open(filename, "r");
        if (!pngFile) {
            Serial.printf("Error: Could not open %s file\n", filename);
            return false;
        }
        
        // Get file size
        size_t fileSize = pngFile.size();
        
        if (fileSize == 0) {
            Serial.println("File is empty");
            pngFile.close();
            return false;
        }
        
        // Read file into buffer
        uint8_t *buffer = (uint8_t*)malloc(fileSize);
        if (!buffer) {
            Serial.println("Failed to allocate memory for PNG");
            pngFile.close();
            return false;
        }
        
        size_t bytesRead = pngFile.read(buffer, fileSize);
        pngFile.close();
        
        if (bytesRead != fileSize) {
            Serial.println("Failed to read complete PNG file");
            free(buffer);
            return false;
        }
        
        // Set up PNG decoder
        int16_t rc = png.openRAM(buffer, fileSize, pngDraw);
        
        if (rc != PNG_SUCCESS) {
            Serial.printf("PNG header decode error: %d\n", rc);
            free(buffer);
            return false;
        }
        
        // Get dimensions
        int16_t pngWidth = png.getWidth();
        int16_t pngHeight = png.getHeight();
        
        // Set up custom parameters
        PNG_DRAW_PARAMS params;
        params.x = x - (pngWidth / 2);  // Center horizontally
        params.y = y - (pngHeight / 2); // Center vertically
        params.color = TFT_WHITE;
        
        // Decode and render
        rc = png.decode(&params, PNG_FAST_PALETTE);
        
        // Clean up
        free(buffer);
        png.close();
        
        if (rc != PNG_SUCCESS) {
            Serial.printf("PNG decode error: %d\n", rc);
            return false;
        }
        
        return true;
    }
    
    void drawTrendIndicator(int x, int y, const char* trend, uint16_t color) {
        // Find matching trend direction
        int trendIndex = 0; // Default to "None"
        for (int i = 0; i < 10; i++) {
            if (strcmp(trend, DEXCOM_TREND_DIRECTIONS[i]) == 0) {
                trendIndex = i;
                break;
            }
        }
        
        // Skip drawing for None (index 0)
        if (trendIndex == 0) {
            return;
        }
        
        // Check if PNG exists before trying to draw
        if (SPIFFS.exists(TREND_PNG_FILES[trendIndex])) {
            if (drawPNG(TREND_PNG_FILES[trendIndex], x, y)) {
                return; // Success
            }
        }
        
        // Fall back to text if PNG fails
        tft.setTextSize(3);
        tft.setTextColor(color);
        tft.setCursor(x - 15, y - 15);
        
        // Text fallback
        switch (trendIndex) {
            case 1: tft.print("^^"); break;  // DoubleUp
            case 2: tft.print("^"); break;   // SingleUp
            case 3: tft.print("/"); break;   // FortyFiveUp  
            case 4: tft.print("->"); break;  // Flat
            case 5: tft.print("\\"); break;  // FortyFiveDown
            case 6: tft.print("v"); break;   // SingleDown
            case 7: tft.print("vv"); break;  // DoubleDown
            case 8: tft.print("?"); break;   // NotComputable
            case 9: tft.print("-"); break;   // RateOutOfRange
            default: break;
        }
    }
    
    void updateTimeDisplay() {
        char timeAgoStr[30];
        int timeSize = 2;
        int statusY = tft.height() - 30;
        
        // Calculate time since last reading
        if (lastDexcomReadingTime > 1000000) { // Valid timestamp
            time_t now = time(nullptr);
            unsigned long long currentEpochMillis = ((unsigned long long)now) * 1000;
            
            unsigned long minutesAgo = 0;
            
            if (currentEpochMillis > lastDexcomReadingTime) {
                // Normal case - reading is in the past
                unsigned long timeDiff = currentEpochMillis - lastDexcomReadingTime;
                minutesAgo = timeDiff / 60000;
            } else {
                // Clock issue - handle gracefully
                unsigned long timeDiff = lastDexcomReadingTime - currentEpochMillis;
                Serial.print("WARNING: Reading appears to be from the future by ");
                Serial.print(timeDiff / 60000);
                Serial.println(" minutes");
                
                // Use local time instead
                timeDiff = millis() - millis(); // Last update time
                minutesAgo = timeDiff / 60000;
            }
            
            // Format the "ago" message
            if (minutesAgo == 0) {
                strcpy(timeAgoStr, "Just now");
            } else if (minutesAgo == 1) {
                strcpy(timeAgoStr, "1 min ago");
            } else if (minutesAgo < 60) {
                snprintf(timeAgoStr, sizeof(timeAgoStr), "%lu mins ago", minutesAgo);
            } else if (minutesAgo < 24 * 60) {
                unsigned long hoursAgo = minutesAgo / 60;
                if (hoursAgo == 1) {
                    snprintf(timeAgoStr, sizeof(timeAgoStr), "1 hour ago");
                } else {
                    snprintf(timeAgoStr, sizeof(timeAgoStr), "%lu hours ago", hoursAgo);
                }
            } else if (minutesAgo < 7 * 24 * 60) {
                unsigned long daysAgo = minutesAgo / (24 * 60);
                snprintf(timeAgoStr, sizeof(timeAgoStr), "%lu days ago", daysAgo);
            } else {
                // Over a week old - show date
                struct tm timeInfo;
                time_t seconds = lastDexcomReadingTime / 1000;
                gmtime_r(&seconds, &timeInfo);
                strftime(timeAgoStr, sizeof(timeAgoStr), "%m-%d %H:%M", &timeInfo);
            }
            
            // Set color based on age
            uint16_t timeColor = TFT_WHITE; // Default
            if (minutesAgo >= 6) {
                timeColor = TFT_RED; // Old reading
            }
            
            // Only update if text changed
            if (strcmp(lastDisplayedTimeStr, timeAgoStr) != 0 || lastDisplayedTimeStr[0] == '\0') {
                // Clear only the time area
                tft.fillRect(0, statusY - 5, tft.width(), 35, TFT_BLACK);
                
                // Center text
                int timeWidth = strlen(timeAgoStr) * 6 * timeSize;
                int timeX = (tft.width() - timeWidth) / 2;
                
                tft.setTextSize(timeSize);
                tft.setTextColor(timeColor);
                tft.setCursor(timeX, statusY);
                tft.print(timeAgoStr);
                
                // Remember displayed text
                strncpy(lastDisplayedTimeStr, timeAgoStr, sizeof(lastDisplayedTimeStr) - 1);
                lastDisplayedTimeStr[sizeof(lastDisplayedTimeStr) - 1] = '\0';
            }
        } else {
            // No valid timestamp yet
            strcpy(timeAgoStr, "No data yet");
            
            // Only update if text changed
            if (strcmp(lastDisplayedTimeStr, timeAgoStr) != 0) {
                tft.fillRect(0, statusY - 5, tft.width(), 35, TFT_BLACK);
                
                int timeWidth = strlen(timeAgoStr) * 6 * timeSize;
                int timeX = (tft.width() - timeWidth) / 2;
                
                tft.setTextSize(timeSize);
                tft.setTextColor(TFT_WHITE);
                tft.setCursor(timeX, statusY);
                tft.print(timeAgoStr);
                
                strncpy(lastDisplayedTimeStr, timeAgoStr, sizeof(lastDisplayedTimeStr) - 1);
                lastDisplayedTimeStr[sizeof(lastDisplayedTimeStr) - 1] = '\0';
            }
        }
    }
    
    void updateDisplay() {
        // Only refresh if something changed
        bool glucoseChanged = (lastDisplayedGlucose != current_glucose_mgdl);
        bool trendChanged = (strcmp(lastDisplayedTrend, trend) != 0);
        bool unitsChanged = (lastDisplayedMgDL != displayMgDL);
        
        if (!glucoseChanged && !trendChanged && !unitsChanged && !displayNeedsFullUpdate) {
            return;
        }
        
        // Save current values for next comparison
        lastDisplayedGlucose = current_glucose_mgdl;
        strncpy(lastDisplayedTrend, trend, sizeof(lastDisplayedTrend) - 1);
        lastDisplayedTrend[sizeof(lastDisplayedTrend) - 1] = '\0';
        lastDisplayedMgDL = displayMgDL;
        
        // Clear the screen
        tft.fillScreen(TFT_BLACK);
        
        // Maintain touch area for title functionality, but don't display it
        titleTouchX = 0;
        titleTouchY = 0;
        titleTouchWidth = tft.width();
        titleTouchHeight = 30;
        
        // Create hidden settings button in top left
        settingsTouchX = 0;
        settingsTouchY = 0;
        settingsTouchWidth = 40;
        settingsTouchHeight = 40;
        
        // Small indicator for settings button
        tft.fillCircle(5, 5, 2, TFT_DARKGREY);
        
        // Format glucose value as string
        char glucoseStr[10];
        
        if (displayMgDL) {
            // Show mg/dL
            sprintf(glucoseStr, "%.0f", current_glucose_mgdl);
        } else {
            // Show mmol/L
            sprintf(glucoseStr, "%.1f", glucose_mmol);
        }
        
        int numDigits = strlen(glucoseStr);
        
        // Determine color based on glucose level
        uint16_t colorBasedOnGlucose;
        if (current_glucose_mgdl > 180) {
            colorBasedOnGlucose = COLOR_BG_HIGH;
        } else if (current_glucose_mgdl < 70) {
            colorBasedOnGlucose = COLOR_BG_LOW;
        } else {
            colorBasedOnGlucose = COLOR_BG_NORMAL;
        }
        
        // Calculate layout
        const int displayWidth = tft.width();
        const int displayHeight = tft.height();
        const int glucoseSize = 8;
        const int charWidth = 6 * glucoseSize;
        int glucoseWidth = numDigits * charWidth;
        
        // Vertical spacing
        const int glucoseHeight = glucoseSize * 8;
        const int spaceBetween = 50;
        const int arrowHeight = 32;
        const int totalContentHeight = glucoseHeight + spaceBetween + arrowHeight;
        
        // No space needed at top for title since we're not displaying it
        int topMargin = 30;
        
        // Start Y position for content
        int startY = topMargin + ((displayHeight - totalContentHeight - topMargin - 40) / 2);
        
        // Position elements
        int glucoseY = startY;
        int arrowY = startY + glucoseHeight + spaceBetween;
        
        // Center glucose horizontally
        int glucoseX = (displayWidth - glucoseWidth) / 2;
        
        // Store touch area for glucose
        glucoseTouchX = glucoseX;
        glucoseTouchY = glucoseY;
        glucoseTouchWidth = glucoseWidth;
        glucoseTouchHeight = glucoseHeight;
        
        // Display glucose value
        tft.setTextSize(glucoseSize);
        tft.setTextColor(colorBasedOnGlucose);
        tft.setCursor(glucoseX, glucoseY);
        tft.print(glucoseStr);
        
        // Check if we're in large differential mode
        if (displayLargeDifferential) {
            // Make glucose large and differential smaller
            int glucoseDisplaySize = 8;  // Original large size
            int diffDisplaySize = 6;     // Smaller size for differential
            
            // Calculate heights and widths
            int glucoseDisplayHeight = glucoseDisplaySize * 8;
            int diffDisplayHeight = diffDisplaySize * 8;
            int charGlucoseWidth = 6 * glucoseDisplaySize;
            int charDiffWidth = 6 * diffDisplaySize;
            
            // Format glucose and differential strings
            char diffStr[15];
            if (glucose_diff > 0) {
                sprintf(diffStr, "+%.0f", glucose_diff);
            } else if (glucose_diff < 0) {
                sprintf(diffStr, "%.0f", glucose_diff);
            } else {
                sprintf(diffStr, "+0");
            }
            
            // Calculate exact widths
            int glucosePixelWidth = strlen(glucoseStr) * charGlucoseWidth;
            int diffPixelWidth = strlen(diffStr) * charDiffWidth;
            
            // Spacing between the values
            int spacing = 5;  // Minimal spacing for a very tight layout
            
            // Calculate total width needed
            int totalWidth = glucosePixelWidth + spacing + diffPixelWidth;
            
            // Center this total width on screen
            int startX = (displayWidth - totalWidth) / 2;
            
            // Clear display area first - using max height of glucose
            tft.fillRect(0, glucoseY, displayWidth, glucoseDisplayHeight + 10, TFT_BLACK);
            
            // Determine color for differential
            uint16_t diffColor;
            if (glucose_diff > 0) {
                diffColor = TFT_GREEN;
            } else if (glucose_diff < 0) {
                diffColor = TFT_RED;
            } else {
                diffColor = TFT_WHITE;
            }
            
            // Display large glucose value on left 
            tft.setTextSize(glucoseDisplaySize);
            tft.setTextColor(colorBasedOnGlucose);
            tft.setCursor(startX, glucoseY);
            tft.print(glucoseStr);
            
            // Calculate vertical adjustment to align differential with glucose
            // This centers the differential vertically with the glucose text
            int verticalOffset = (glucoseDisplayHeight - diffDisplayHeight) / 2;
            
            // Display smaller differential on right, vertically centered
            tft.setTextSize(diffDisplaySize);
            tft.setTextColor(diffColor);
            tft.setCursor(startX + glucosePixelWidth + spacing, glucoseY + verticalOffset);
            tft.print(diffStr);
            
            // Update touch areas
            glucoseTouchX = startX;
            glucoseTouchY = glucoseY;
            glucoseTouchWidth = glucosePixelWidth;
            glucoseTouchHeight = glucoseDisplayHeight;
            
            diffTouchX = startX + glucosePixelWidth + spacing;
            diffTouchY = glucoseY + verticalOffset;
            diffTouchWidth = diffPixelWidth;
            diffTouchHeight = diffDisplayHeight;
        } else {
            // Units display (only in normal mode)
            int unitsSize = 2;
            tft.setTextSize(unitsSize);
            tft.setTextColor(TFT_WHITE);
            
            // Position for units
            int unitsOffset = 10;
            int unitsX;
            
            if (displayMgDL) {
                unitsX = glucoseX + glucoseWidth + unitsOffset;
            } else {
                // Ensure mmol/L fits on screen
                int mmolTextWidth = 6 * unitsSize * 6;
                int maxUnitsX = displayWidth - mmolTextWidth - 5;
                unitsX = min(glucoseX + glucoseWidth + unitsOffset, maxUnitsX);
            }
            
            tft.setCursor(unitsX, glucoseY + 20);
            
            // Show units
            if (displayMgDL) {
                tft.print("mg/dL");
            } else {
                tft.print("mmol/L");
            }
            
            // Glucose change indicator (small in normal mode)
            tft.setTextSize(2);
            tft.setCursor(glucoseX + glucoseWidth + 10, glucoseY);
            
            int diffX = glucoseX + glucoseWidth + 10;
            int diffY = glucoseY;
            int diffWidth = 0;
            
            if (glucose_diff > 0) {
                tft.setTextColor(TFT_GREEN);
                tft.printf("+%.0f", glucose_diff);
                diffWidth = (glucose_diff < 10) ? 30 : 40; // Estimate width based on digits
            } else if (glucose_diff < 0) {
                tft.setTextColor(TFT_RED);
                tft.printf("%.0f", glucose_diff);
                diffWidth = (abs(glucose_diff) < 10) ? 20 : 30; // Estimate width based on digits
            } else {
                tft.setTextColor(TFT_WHITE);
                tft.print("+0");
                diffWidth = 25;
            }
            
            // Set touch area for the differential and units together
            diffTouchX = diffX;
            diffTouchY = diffY;
            diffTouchWidth = diffWidth + 70; // Add extra width to include units
            diffTouchHeight = 40;
        }
        
        // Trend arrow centered horizontally
        int arrowX = displayWidth / 2;
        
        // Draw trend indicator
        drawTrendIndicator(arrowX, arrowY, trend, colorBasedOnGlucose);
        
        // Store arrow touch area
        arrowTouchX = arrowX - 50;
        arrowTouchY = arrowY - 25;
        arrowTouchWidth = 100;
        arrowTouchHeight = 50;
        
        // Debug touch areas
        if (DEBUG_TOUCH) {
            Serial.println("Touch areas defined:");
            Serial.printf("Glucose: X=%d, Y=%d, W=%d, H=%d\n", 
                         glucoseTouchX, glucoseTouchY, glucoseTouchWidth, glucoseTouchHeight);
            Serial.printf("Arrow: X=%d, Y=%d, W=%d, H=%d\n", 
                         arrowTouchX, arrowTouchY, arrowTouchWidth, arrowTouchHeight);
            Serial.printf("Title: X=%d, Y=%d, W=%d, H=%d\n", 
                         titleTouchX, titleTouchY, titleTouchWidth, titleTouchHeight);
            Serial.printf("Settings: X=%d, Y=%d, W=%d, H=%d\n", 
                         settingsTouchX, settingsTouchY, settingsTouchWidth, settingsTouchHeight);
            Serial.printf("Differential: X=%d, Y=%d, W=%d, H=%d\n", 
                         diffTouchX, diffTouchY, diffTouchWidth, diffTouchHeight);
        }
        
        // Force time display update
        lastDisplayedTimeStr[0] = '\0';
        updateTimeDisplay();
        
        // Draw confirmation dialog if active
        if (displayingConfirmation) {
            drawConfirmationDialog();
        }
    }
    
    void drawSettingsScreen() {
        tft.fillScreen(TFT_BLACK);
        
        // Draw "Settings" title centered
        tft.setTextSize(2);
        tft.setTextColor(TFT_WHITE);
        
        const char* titleText = "Settings";
        int textWidth = strlen(titleText) * 12;
        int titleX = (tft.width() - textWidth) / 2;
        
        tft.setCursor(titleX, 20);
        tft.print(titleText);
        
        // Subtle line under title
        tft.drawLine(titleX, 40, titleX + textWidth, 40, TFT_DARKGREY);
        
        // Calculate grid layout (3x2 grid) for 6 buttons
        int gridCols = 3;
        int gridRows = 2;
        int gridSpacingX = 10; // Space between columns
        int gridSpacingY = 10; // Space between rows
        int gridMargin = 20;   // Margin from screen edges
        
        // Calculate button dimensions for the grid
        int buttonWidth = (tft.width() - (2 * gridMargin) - ((gridCols - 1) * gridSpacingX)) / gridCols;
        int buttonHeight = 40;  // Fixed height
        
        // Position for Reset button (top-left position in grid)
        int buttonX = gridMargin;
        int buttonY = 60;  // Position below the title
        
        // Store button position for touch detection
        resetButtonX = buttonX;
        resetButtonY = buttonY;
        resetButtonWidth = buttonWidth;
        resetButtonHeight = buttonHeight;
        
        // Draw button
        tft.fillRoundRect(buttonX, buttonY, buttonWidth, buttonHeight, 8, TFT_BLUE);
        tft.drawRoundRect(buttonX, buttonY, buttonWidth, buttonHeight, 8, TFT_WHITE);
        
        // Button text
        tft.setTextSize(2);
        tft.setTextColor(TFT_WHITE);
        const char* buttonText = "Reset";  // Changed from "Reset Credentials" to "Reset"
        textWidth = strlen(buttonText) * 12;
        int buttonTextX = buttonX + (buttonWidth - textWidth) / 2;
        int buttonTextY = buttonY + (buttonHeight - 16) / 2;
        tft.setCursor(buttonTextX, buttonTextY);
        tft.print(buttonText);
        
        // Explicitly clear bottom area where timer would be displayed
        tft.fillRect(0, tft.height() - 35, tft.width(), 35, TFT_BLACK);
        
        // Instructions centered and at the very bottom of the screen
        tft.setTextSize(1);
        const char* returnText = "Tap anywhere else to return";
        textWidth = strlen(returnText) * 6;  // Font width is 6 for text size 1
        int returnTextX = (tft.width() - textWidth) / 2;
        int returnTextY = tft.height() - 15;  // Very bottom positioning
        
        tft.setCursor(returnTextX, returnTextY);
        tft.print(returnText);
        
        // Draw confirmation dialog if active
        if (displayingConfirmation) {
            drawConfirmationDialog();
        }
    }
    
    void drawConfirmationDialog() {
        // Dialog dimensions
        int dialogWidth = 240;
        int dialogHeight = 120;
        int dialogX = (tft.width() - dialogWidth) / 2;
        int dialogY = (tft.height() - dialogHeight) / 2;
        
        // Draw dialog background with shadow effect
        tft.fillRoundRect(dialogX + 3, dialogY + 3, dialogWidth, dialogHeight, 8, TFT_DARKGREY);
        tft.fillRoundRect(dialogX, dialogY, dialogWidth, dialogHeight, 8, TFT_NAVY);
        tft.drawRoundRect(dialogX, dialogY, dialogWidth, dialogHeight, 8, TFT_WHITE);
        
        // Dialog title
        tft.setTextSize(2);
        tft.setTextColor(TFT_WHITE);
        const char* titleText = "Confirm Reset";
        int textWidth = strlen(titleText) * 12;
        int titleX = dialogX + (dialogWidth - textWidth) / 2;
        tft.setCursor(titleX, dialogY + 15);
        tft.print(titleText);
        
        // Dialog message
        tft.setTextSize(1);
        const char* messageText = "Reset WiFi and Dexcom credentials?";
        textWidth = strlen(messageText) * 6;
        int messageX = dialogX + (dialogWidth - textWidth) / 2;
        tft.setCursor(messageX, dialogY + 40);
        tft.print(messageText);
        
        // Yes button
        int buttonWidth = 80;
        int buttonHeight = 30;
        int buttonSpacing = 20;
        int yesButtonX = dialogX + (dialogWidth / 2) - buttonWidth - (buttonSpacing / 2);
        int buttonY = dialogY + dialogHeight - buttonHeight - 15;
        
        confirmYesX = yesButtonX;
        confirmYesY = buttonY;
        confirmYesWidth = buttonWidth;
        confirmYesHeight = buttonHeight;
        
        tft.fillRoundRect(yesButtonX, buttonY, buttonWidth, buttonHeight, 4, TFT_RED);
        tft.drawRoundRect(yesButtonX, buttonY, buttonWidth, buttonHeight, 4, TFT_WHITE);
        
        // Yes button text
        tft.setTextSize(2);
        const char* yesText = "Yes";
        textWidth = strlen(yesText) * 12;
        int yesTextX = yesButtonX + (buttonWidth - textWidth) / 2;
        int buttonTextY = buttonY + (buttonHeight - 16) / 2;
        tft.setCursor(yesTextX, buttonTextY);
        tft.print(yesText);
        
        // No button
        int noButtonX = dialogX + (dialogWidth / 2) + (buttonSpacing / 2);
        
        confirmNoX = noButtonX;
        confirmNoY = buttonY;
        confirmNoWidth = buttonWidth;
        confirmNoHeight = buttonHeight;
        
        tft.fillRoundRect(noButtonX, buttonY, buttonWidth, buttonHeight, 4, TFT_GREEN);
        tft.drawRoundRect(noButtonX, buttonY, buttonWidth, buttonHeight, 4, TFT_WHITE);
        
        // No button text
        const char* noText = "No";
        textWidth = strlen(noText) * 12;
        int noTextX = noButtonX + (buttonWidth - textWidth) / 2;
        tft.setCursor(noTextX, buttonTextY);
        tft.print(noText);
    }
    
    void drawKeyboard() {
        tft.fillScreen(TFT_BLACK);
        
        // Draw title
        tft.setTextSize(2);
        tft.setTextColor(TFT_WHITE);
        tft.setCursor(10, 5);
        tft.print("Enter Custom Title:");
        
        // Draw input field
        int inputFieldX = 10;
        int inputFieldY = 30;
        int inputFieldWidth = tft.width() - 20;
        int inputFieldHeight = 25;
        
        tft.drawRect(inputFieldX, inputFieldY, inputFieldWidth, inputFieldHeight, TFT_WHITE);
        tft.setTextSize(2);
        tft.setCursor(inputFieldX + 5, inputFieldY + 5);
        tft.print(inputBuffer);
        
        // Draw cursor
        int cursorX = inputFieldX + 5 + (inputPosition * 12);
        if (cursorX < inputFieldX + inputFieldWidth - 10) {
            if ((millis() / 500) % 2 == 0) {
                tft.fillRect(cursorX, inputFieldY + 5, 2, 15, TFT_WHITE);
            }
        }
        
        // Draw buttons
        int buttonY = inputFieldY + inputFieldHeight + 5;
        int buttonHeight = 25;
        int buttonWidth = (tft.width() - 30) / 2;
        
        // Cancel button
        tft.drawRect(10, buttonY, buttonWidth, buttonHeight, TFT_WHITE);
        tft.setCursor(10 + (buttonWidth/2) - 30, buttonY + 5);
        tft.print("Cancel");
        
        // OK button
        tft.drawRect(20 + buttonWidth, buttonY, buttonWidth, buttonHeight, TFT_WHITE);
        tft.setCursor(20 + buttonWidth + (buttonWidth/2) - 15, buttonY + 5);
        tft.print("OK");
        
        // Draw keyboard rows
        int keyboardStartY = KEYBOARD_Y;
        
        // Keyboard background
        tft.fillRect(0, keyboardStartY, tft.width(), tft.height() - keyboardStartY, TFT_DARKGREY);
        
        for (int row = 0; row < KEYBOARD_ROWS; row++) {
            for (int col = 0; col < KEYBOARD_COLS; col++) {
                int keyX = col * KEY_WIDTH;
                int keyY = keyboardStartY + (row * KEY_HEIGHT);
                char keyChar = keyboardLayout[row][col];
                
                // Skip blanks except space key
                if (keyChar == ' ' && !(row == 2 && col == 9)) {
                    continue;
                }
                
                // Special keys
                if (row == 3 && col >= 7) {
                    if (col == 7) {
                        // Backspace key
                        tft.fillRect(keyX, keyY, KEY_WIDTH * 3, KEY_HEIGHT, TFT_NAVY);
                        tft.drawRect(keyX, keyY, KEY_WIDTH * 3, KEY_HEIGHT, TFT_WHITE);
                        tft.setTextSize(2);
                        tft.setTextColor(TFT_WHITE);
                        tft.setCursor(keyX + KEY_WIDTH - 5, keyY + 6);
                        tft.print("BKSP");
                    }
                    continue;
                }
                
                // Regular key
                tft.fillRect(keyX, keyY, KEY_WIDTH, KEY_HEIGHT, TFT_NAVY);
                tft.drawRect(keyX, keyY, KEY_WIDTH, KEY_HEIGHT, TFT_WHITE);
                
                tft.setTextSize(2);
                tft.setTextColor(TFT_WHITE);
                tft.setCursor(keyX + (KEY_WIDTH/2) - 6, keyY + 6);
                tft.print(keyChar);
            }
        }
    }
    
    void processKeyPress(int x, int y) {
        // Check if in keyboard area
        if (y < KEYBOARD_Y) {
            // Above keyboard - check buttons
            int middleX = tft.width() / 2;
            
            // OK button (right side)
            if (x > middleX && y >= 18 && y <= 48) {
                saveCustomTitle();
                toggleKeyboard(false); // Use our toggle method
                return;
            }
            
            // Cancel button (left side)
            if (x <= middleX && y >= 18 && y <= 48) {
                toggleKeyboard(false); // Use our toggle method
                return;
            }
            
            return;
        }
        
        // Process keyboard keys
        int keyY = (y - KEYBOARD_Y) / KEY_HEIGHT;
        int keyX = x / KEY_WIDTH;
        
        // Validate key position
        if (keyY >= 0 && keyY < KEYBOARD_ROWS && keyX >= 0 && keyX < KEYBOARD_COLS) {
            char keyChar = keyboardLayout[keyY][keyX];
            
            // Handle special keys
            if (keyY == 2 && keyX == 9) {
                // Space
                if (inputPosition < sizeof(inputBuffer) - 1) {
                    inputBuffer[inputPosition++] = ' ';
                    inputBuffer[inputPosition] = '\0';
                }
            } 
            else if (keyY == 3 && keyX >= 7) {
                // Backspace
                if (inputPosition > 0) {
                    inputPosition--;
                    inputBuffer[inputPosition] = '\0';
                }
            }
            else if (keyChar != ' ') {
                // Add character if buffer not full
                if (inputPosition < sizeof(inputBuffer) - 1) {
                    inputBuffer[inputPosition++] = keyChar;
                    inputBuffer[inputPosition] = '\0';
                }
            }
            
            // Immediately redraw keyboard to show updated input
            drawKeyboard();
        }
    }
    
    void saveCustomTitle() {
        strncpy(settings.customTitle, inputBuffer, sizeof(settings.customTitle) - 1);
        settings.customTitle[sizeof(settings.customTitle) - 1] = '\0';
        settings.save();
    }
    
    void storeGlucoseReading(float value, unsigned long timestamp) {
        // Shift all readings back
        for (int i = MAX_GLUCOSE_HISTORY - 1; i > 0; i--) {
            glucoseHistory[i] = glucoseHistory[i-1];
        }
        
        // Store new reading at position 0
        glucoseHistory[0].value = value;
        glucoseHistory[0].timestamp = timestamp;
        
        // Update count
        if (glucoseHistoryCount < MAX_GLUCOSE_HISTORY) {
            glucoseHistoryCount++;
        }
    }
    
    void drawGlucoseGraph() {
        // Define graph area
        const int margin = 15;
        const int graphX = margin;
        const int graphY = 50;
        const int graphWidth = tft.width() - (margin * 2);
        const int graphHeight = tft.height() - graphY - 40;
        
        // Clear screen
        tft.fillScreen(TFT_BLACK);
        
        // Graph title
        tft.setTextSize(2);
        tft.setTextColor(TFT_WHITE);
        
        const char* titleText = "Glucose History";
        int textWidth = strlen(titleText) * 12;
        int titleX = (tft.width() - textWidth) / 2;
        
        tft.setCursor(titleX, 10);
        tft.print(titleText);
        
        // Draw graph frame
        tft.drawRect(graphX, graphY, graphWidth, graphHeight, TFT_WHITE);
        
        // Check if we have data
        if (glucoseHistoryCount == 0) {
            tft.setTextSize(2);
            tft.setCursor(margin + 20, graphY + (graphHeight / 2) - 10);
            tft.print("No history data available");
            
            tft.setTextSize(1);
            tft.setCursor(margin + 20, tft.height() - 30);
            tft.print("Tap anywhere to return to normal view");
            return;
        }
        
        // Find min and max values for scaling
        float minValue = 999;
        float maxValue = 0;
        
        for (int i = 0; i < glucoseHistoryCount; i++) {
            if (glucoseHistory[i].value < minValue) {
                minValue = glucoseHistory[i].value;
            }
            if (glucoseHistory[i].value > maxValue) {
                maxValue = glucoseHistory[i].value;
            }
        }
        
        // Add padding to min/max
        minValue = max(0.0f, minValue - (maxValue - minValue) * 0.1f);
        maxValue = maxValue + (maxValue - minValue) * 0.1f;
        
        // Ensure range includes critical values
        if (minValue > 70) minValue = 70;
        if (maxValue < 180) maxValue = 180;
        
        // Draw threshold lines
        int lowY = graphY + graphHeight - (70 - minValue) * graphHeight / (maxValue - minValue);
        int highY = graphY + graphHeight - (180 - minValue) * graphHeight / (maxValue - minValue);
        
        if (lowY <= graphY + graphHeight && lowY >= graphY) {
            tft.drawFastHLine(graphX, lowY, graphWidth, TFT_BLUE);
        }
        if (highY <= graphY + graphHeight && highY >= graphY) {
            tft.drawFastHLine(graphX, highY, graphWidth, TFT_YELLOW);
        }
        
        // Draw y-axis labels
        tft.setTextSize(1);
        tft.setCursor(graphX - 12, graphY - 5);
        tft.print((int)maxValue);
        
        tft.setCursor(graphX - 12, graphY + (graphHeight / 2) - 5);
        tft.print((int)((maxValue + minValue) / 2));
        
        tft.setCursor(graphX - 12, graphY + graphHeight - 5);
        tft.print((int)minValue);
        
        // Draw the data points and connect with lines
        int prevX = 0;
        int prevY = 0;
        
        for (int i = 0; i < glucoseHistoryCount; i++) {
            // X position (oldest to newest, left to right)
            int x = graphX + (i * graphWidth / (glucoseHistoryCount - 1));
            
            // Y position (invert for screen coordinates)
            int y = graphY + graphHeight - ((glucoseHistory[i].value - minValue) * graphHeight / (maxValue - minValue));
            
            // Color based on value
            uint16_t pointColor;
            if (glucoseHistory[i].value > 180) {
                pointColor = TFT_YELLOW;
            } else if (glucoseHistory[i].value < 70) {
                pointColor = TFT_BLUE;
            } else {
                pointColor = TFT_GREEN;
            }
            
            // Draw point
            tft.fillCircle(x, y, 2, pointColor);
            
            // Connect with line from previous point
            if (i > 0) {
                tft.drawLine(prevX, prevY, x, y, pointColor);
            }
            
            prevX = x;
            prevY = y;
        }
        
        // Instructions to return
        tft.setTextSize(1);
        tft.setTextColor(TFT_WHITE);
        tft.setCursor(margin + 20, graphY + graphHeight + 5);
        tft.print("Tap anywhere to return to normal view");
    }
    
    // IMPROVED TOGGLE METHODS
    
    void toggleDisplayMode() {
        displayMgDL = !displayMgDL;
        displayNeedsFullUpdate = true;
    }
    
    void toggleGraph(bool show) {
        // Only update state if it's changing
        if (displayingGraph != show) {
            displayingGraph = show;
            
            if (show) {
                // Make sure other views are closed
                displayingKeyboard = false;
                displayingSettings = false;
                displayingConfirmation = false;
                
                // Force a full screen refresh
                tft.fillScreen(TFT_BLACK);
                displayNeedsFullUpdate = true;
            } else {
                // Going back to main screen
                tft.fillScreen(TFT_BLACK);
                displayNeedsFullUpdate = true;
            }
        }
    }
    
    void toggleKeyboard(bool show) {
        // Only update state if it's changing
        if (displayingKeyboard != show) {
            displayingKeyboard = show;
            
            if (show) {
                // Make sure other views are closed
                displayingGraph = false;
                displayingSettings = false;
                displayingConfirmation = false;
                
                // Initialize input buffer with current title
                strncpy(inputBuffer, settings.customTitle, sizeof(inputBuffer) - 1);
                inputBuffer[sizeof(inputBuffer) - 1] = '\0';
                inputPosition = strlen(inputBuffer);
                
                // Force a full screen refresh
                tft.fillScreen(TFT_BLACK);
                displayNeedsFullUpdate = true;
            } else {
                // Going back to main screen
                tft.fillScreen(TFT_BLACK);
                displayNeedsFullUpdate = true;
            }
        }
    }
    
    void toggleSettings(bool show) {
        // Only update state if it's changing
        if (displayingSettings != show) {
            displayingSettings = show;
            
            if (show) {
                // Make sure other views are closed
                displayingGraph = false;
                displayingKeyboard = false;
                displayingConfirmation = false;
                
                // Force a full screen refresh
                tft.fillScreen(TFT_BLACK);
                displayNeedsFullUpdate = true;
            } else {
                // Going back to main screen
                tft.fillScreen(TFT_BLACK);
                displayNeedsFullUpdate = true;
            }
        }
    }
    
    void toggleConfirmation(bool show) {
        // Only update state if it's changing
        if (displayingConfirmation != show) {
            displayingConfirmation = show;
            
            // Force a full screen refresh if showing confirmation
            if (show) {
                displayNeedsFullUpdate = true;
            }
        }
    }
    
    // Process reset credentials action
    bool handleResetCredentialsTouch(int x, int y) {
        // Check if confirmation is active
        if (displayingConfirmation) {
            // Check if "Yes" button was pressed
            if (x >= confirmYesX && x <= (confirmYesX + confirmYesWidth) && 
                y >= confirmYesY && y <= (confirmYesY + confirmYesHeight)) {
                
                // User confirmed reset
                displayingConfirmation = false;
                displayingSettings = false;
                
                // Mark global flag to trigger reset on next restart
                shouldResetSettings = true;
                
                // Show reset message
                tft.fillScreen(TFT_BLACK);
                tft.setTextSize(2);
                tft.setCursor(20, 60);
                tft.println("Resetting settings...");
                
                // Reset WiFi settings BEFORE restarting
                WiFiManager wifiManager;
                wifiManager.resetSettings();
                
                // Reset Dexcom credentials
                settings.reset();
                
                tft.setCursor(20, 90);
                tft.println("Restarting...");
                tft.setCursor(20, 120);
                tft.println("Connect to WiFi network:");
                tft.setCursor(20, 150);
                tft.println("Dexcom-Monitor-Setup");
                
                delay(3000);
                return true;  // Return true to indicate we should restart
            }
            
            // Check if "No" button was pressed
            if (x >= confirmNoX && x <= (confirmNoX + confirmNoWidth) && 
                y >= confirmNoY && y <= (confirmNoY + confirmNoHeight)) {
                
                // User cancelled - hide dialog but stay in settings
                displayingConfirmation = false;
                displayNeedsFullUpdate = true;
            }
            
            return false;
        }
        
        // Check if settings is active and reset button was pressed
        if (displayingSettings && 
            x >= resetButtonX && x <= (resetButtonX + resetButtonWidth) && 
            y >= resetButtonY && y <= (resetButtonY + resetButtonHeight)) {
            
            // Show confirmation dialog
            displayingConfirmation = true;
            displayNeedsFullUpdate = true;
        }
        
        return false;
    }
    
    // Set glucose data
    void setGlucoseData(float current, float previous, char* trendValue, char* time, unsigned long dexcomTime) {
        current_glucose_mgdl = current;
        previous_glucose_mgdl = previous;
        glucose_diff = current - previous;
        glucose_mmol = current / 18.0;
        
        strncpy(trend, trendValue, sizeof(trend) - 1);
        trend[sizeof(trend) - 1] = '\0';
        
        strncpy(timestamp, time, sizeof(timestamp) - 1);
        timestamp[sizeof(timestamp) - 1] = '\0';
        
        lastDexcomReadingTime = dexcomTime;
        
        // Mark for update if values changed
        if (lastDisplayedGlucose != current_glucose_mgdl || 
            strcmp(lastDisplayedTrend, trend) != 0) {
            displayNeedsFullUpdate = true;
            
            // Store reading in history
            storeGlucoseReading(current, dexcomTime / 1000);
        }
    }
    
    // Touch handling helpers
    void getTouchAreas(int& gX, int& gY, int& gW, int& gH, 
                      int& aX, int& aY, int& aW, int& aH,
                      int& tX, int& tY, int& tW, int& tH,
                      int& sX, int& sY, int& sW, int& sH,
                      int& dX, int& dY, int& dW, int& dH) {
        gX = glucoseTouchX; gY = glucoseTouchY; gW = glucoseTouchWidth; gH = glucoseTouchHeight;
        aX = arrowTouchX; aY = arrowTouchY; aW = arrowTouchWidth; aH = arrowTouchHeight;
        tX = titleTouchX; tY = titleTouchY; tW = titleTouchWidth; tH = titleTouchHeight;
        sX = settingsTouchX; sY = settingsTouchY; sW = settingsTouchWidth; sH = settingsTouchHeight;
        dX = diffTouchX; dY = diffTouchY; dW = diffTouchWidth; dH = diffTouchHeight;
    }
    
    // Get Reset button position
    void getResetButtonArea(int& rX, int& rY, int& rW, int& rH) {
        rX = resetButtonX; rY = resetButtonY; rW = resetButtonWidth; rH = resetButtonHeight;
    }
    
    // Get confirmation button positions
    void getConfirmButtonAreas(int& yesX, int& yesY, int& yesW, int& yesH,
                             int& noX, int& noY, int& noW, int& noH) {
        yesX = confirmYesX; yesY = confirmYesY; yesW = confirmYesWidth; yesH = confirmYesHeight;
        noX = confirmNoX; noY = confirmNoY; noW = confirmNoWidth; noH = confirmNoHeight;
    }
    
    // State getters
    bool needsFullUpdate() const { return displayNeedsFullUpdate; }
    bool needsTimeUpdate() const { return displayNeedsTimeUpdate; }
    void clearFullUpdate() { displayNeedsFullUpdate = false; }
    void clearTimeUpdate() { displayNeedsTimeUpdate = false; }
    bool isDisplayingGraph() const { return displayingGraph; }
    bool isDisplayingKeyboard() const { return displayingKeyboard; }
    bool isDisplayingSettings() const { return displayingSettings; }
    bool isDisplayingConfirmation() const { return displayingConfirmation; }
    bool isDisplayingLargeDifferential() const { return displayLargeDifferential; }
};

// Global display manager
DisplayManager displayManager;

// Touch handler class
class TouchHandler {
private:
    bool touchEnabled = false;
    unsigned long lastTouchTime = 0;
    
public:
    bool init() {
        touchscreenSPI.begin(XPT2046_CLK, XPT2046_MISO, XPT2046_MOSI, XPT2046_CS);
        if (touchscreen.begin(touchscreenSPI)) {
            Serial.println("Touch screen initialized");
            touchEnabled = true;
            touchscreen.setRotation(1); // Match TFT rotation
            return true;
        } else {
            Serial.println("Touch screen initialization failed");
            return false;
        }
    }
    
    // IMPROVED TOUCH HANDLING
    bool handleTouch(unsigned long currentTime) {
        if (!touchEnabled) return false;
        
        // Check if touch is detected and debounce it
        if (touchscreen.tirqTouched() && touchscreen.touched() && 
            currentTime - lastTouchTime > TOUCH_DEBOUNCE) {
            
            TS_Point p = touchscreen.getPoint();
            
            // Convert touch coordinates to screen coordinates
            // IMPORTANT: These mapping values may need adjustment for your specific hardware
            int touchX = map(p.x, 200, 3700, 0, tft.width());
            int touchY = map(p.y, 240, 3800, 0, tft.height());
            
            // Print touch coordinates for debugging
            if (DEBUG_TOUCH) {
                Serial.print("Touch detected at X=");
                Serial.print(touchX);
                Serial.print(", Y=");
                Serial.print(touchY);
                Serial.print(", Pressure=");
                Serial.println(p.z);
            }
            
            // Get touch areas
            int gX, gY, gW, gH, aX, aY, aW, aH, tX, tY, tW, tH, sX, sY, sW, sH, dX, dY, dW, dH;
            displayManager.getTouchAreas(gX, gY, gW, gH, aX, aY, aW, aH, 
                                         tX, tY, tW, tH, sX, sY, sW, sH, dX, dY, dW, dH);
            
            // Check which area was touched, in proper order of precedence
            
            // First check for reset credentials actions
            if (displayManager.handleResetCredentialsTouch(touchX, touchY)) {
                return true;  // Return true to indicate we should restart
            }
            
            // 1. First check if we're in settings screen - any touch (except settings button) exits
            if (displayManager.isDisplayingSettings()) {
                // Check if settings button was tapped - toggle settings off
                if (touchX >= sX && touchX <= (sX + sW) && touchY >= sY && touchY <= (sY + sH)) {
                    if (DEBUG_TOUCH) Serial.println("Settings button tapped while in settings");
                    displayManager.toggleSettings(false);
                } else if (!displayManager.isDisplayingConfirmation()) {
                    // Any other tap while in settings returns to main screen (as long as confirmation dialog isn't showing)
                    if (DEBUG_TOUCH) Serial.println("Screen tapped while in settings - returning to main");
                    displayManager.toggleSettings(false);
                }
                lastTouchTime = currentTime;
                return false;
            }
            
            // 2. Next, check if we're in graph screen - any touch exits
            if (displayManager.isDisplayingGraph()) {
                if (DEBUG_TOUCH) Serial.println("Screen tapped while in graph - returning to main");
                displayManager.toggleGraph(false);
                lastTouchTime = currentTime;
                return false;
            }
            
            // 3. Next, check if we're in keyboard screen - need to handle keyboard input or exit
            if (displayManager.isDisplayingKeyboard()) {
                if (DEBUG_TOUCH) Serial.println("Touch while in keyboard");
                displayManager.processKeyPress(touchX, touchY);
                lastTouchTime = currentTime;
                return false;
            }
            
            // 4. We're in main screen - check if settings button was tapped
            if (touchX >= sX && touchX <= (sX + sW) && touchY >= sY && touchY <= (sY + sH)) {
                if (DEBUG_TOUCH) Serial.println("Settings button tapped");
                displayManager.toggleSettings(true);
                lastTouchTime = currentTime;
                return false;
            }
            
            // 5. Check if glucose display area was tapped
            if (touchX >= gX && touchX <= (gX + gW) && touchY >= gY && touchY <= (gY + gH)) {
                if (DEBUG_TOUCH) Serial.println("Glucose area tapped - toggling units");
                displayManager.toggleDisplayMode();
                lastTouchTime = currentTime;
                return false;
            }
            
            // 6. Check if differential/units area was tapped
            if (touchX >= dX && touchX <= (dX + dW) && touchY >= dY && touchY <= (dY + dH)) {
                if (DEBUG_TOUCH) Serial.println("Differential/units area tapped - toggling differential mode");
                displayManager.toggleDifferentialMode();
                lastTouchTime = currentTime;
                return false;
            }
            
            // 7. Check if arrow/trend area was tapped
            if (touchX >= aX && touchX <= (aX + aW) && touchY >= aY && touchY <= (aY + aH)) {
                if (DEBUG_TOUCH) Serial.println("Arrow area tapped - showing graph");
                displayManager.toggleGraph(true);
                
                // Fetch history when showing graph
                int count = 0;
                dexcomClient.fetchGlucoseHistory(glucoseHistory, count);
                glucoseHistoryCount = count;
                
                lastTouchTime = currentTime;
                return false;
            }
            
            // 8. Check if title area was tapped
            if (touchX >= tX && touchX <= (tX + tW) && touchY >= tY && touchY <= (tY + tH)) {
                if (DEBUG_TOUCH) Serial.println("Title area tapped - showing keyboard");
                displayManager.toggleKeyboard(true);
                lastTouchTime = currentTime;
                return false;
            }
            
            // Wait a bit to debounce
            delay(50);
        }
        
        return false;
    }
    
    bool isTouchEnabled() const {
        return touchEnabled;
    }
};

// Global touch handler
TouchHandler touchHandler;

// WiFi manager helper class
class WifiHelper {
public:
    static void configModeCallback(WiFiManager *myWiFiManager) {
        Serial.println("Entered config mode");
        displayManager.showConfigMode();
    }

    bool connect() {
        WiFiManager wifiManager;
        
        // Set callback for config mode
        wifiManager.setAPCallback(configModeCallback);
        
        // Add custom parameters for Dexcom credentials
        WiFiManagerParameter custom_dexcom_username("dexcomUser", "Dexcom Username", settings.dexcomUsername, 50);
        WiFiManagerParameter custom_dexcom_password("dexcomPass", "Dexcom Password", settings.dexcomPassword, 50);
        
        // EU/US server selection
        char customHtml[128];
        snprintf(customHtml, sizeof(customHtml), 
                "<br/><label for='euServer'>Use EU Dexcom Server</label><input type='checkbox' id='euServer' name='euServer' value='1' %s>", 
                settings.useEUServer ? "checked" : "");
        WiFiManagerParameter custom_eu_server("euServer", "EU Server", "0", 2, customHtml);
        
        wifiManager.addParameter(&custom_dexcom_username);
        wifiManager.addParameter(&custom_dexcom_password);
        wifiManager.addParameter(&custom_eu_server);
        
        // Reset settings if needed
        if (shouldResetSettings) {
            wifiManager.resetSettings();
        }
        
        // Set connection timeout
        wifiManager.setConnectTimeout(30);
        
        // Connect to WiFi or start config portal
        if (!wifiManager.autoConnect("Dexcom-Monitor-Setup")) {
            Serial.println("Failed to connect and hit timeout");
            tft.fillScreen(TFT_BLACK);
            tft.setCursor(20, 60);
            tft.println("Connection failed!");
            tft.setCursor(20, 90);
            tft.println("Restarting...");
            delay(3000);
            return false;
        }
        
        // Connected to WiFi
        tft.fillScreen(TFT_BLACK);
        tft.setCursor(20, 60);
        tft.println("WiFi Connected!");
        tft.setCursor(20, 90);
        tft.println("IP: " + WiFi.localIP().toString());
        
        // Wait a bit after connection
        delay(2000);
        
        // Save parameters
        strncpy(settings.dexcomUsername, custom_dexcom_username.getValue(), sizeof(settings.dexcomUsername) - 1);
        settings.dexcomUsername[sizeof(settings.dexcomUsername) - 1] = '\0';
        
        strncpy(settings.dexcomPassword, custom_dexcom_password.getValue(), sizeof(settings.dexcomPassword) - 1);
        settings.dexcomPassword[sizeof(settings.dexcomPassword) - 1] = '\0';
        
        settings.useEUServer = (strncmp(custom_eu_server.getValue(), "1", 1) == 0);
        
        // Save settings
        settings.save();
        
        return true;
    }

    void checkConnection() {
        if (WiFi.status() != WL_CONNECTED) {
            Serial.println("WiFi connection lost, reconnecting...");
            
            tft.fillScreen(TFT_BLACK);
            tft.setTextSize(2);
            tft.setTextColor(TFT_RED);
            tft.setCursor(40, 60);
            tft.println("WiFi Down...");
            tft.setCursor(40, 90);
            tft.println("Reconnecting...");
            
            WiFi.disconnect();
            WiFi.reconnect();
            
            unsigned long startTime = millis();
            
            // Try reconnecting for 30 seconds
            while (WiFi.status() != WL_CONNECTED && millis() - startTime < 30000) {
                delay(1000);
                Serial.print(".");
            }
            
            if (WiFi.status() == WL_CONNECTED) {
                Serial.println("\nReconnected to WiFi");
                tft.fillScreen(TFT_BLACK);
                tft.setTextColor(TFT_GREEN);
                tft.setCursor(40, 60);
                tft.println("WiFi Connected");
                delay(2000);
                displayManager.clearFullUpdate();
            } else {
                tft.setTextColor(TFT_RED);
                tft.setCursor(40, 120);
                tft.println("Still disconnected");
                tft.setCursor(40, 150);
                tft.println("Will retry soon...");
            }
        }
    }
};

// Global WiFi helper
WifiHelper wifiHelper;

// Setup time via NTP
void setupTime() {
    configTime(0, 0, "pool.ntp.org", "time.nist.gov", "time.google.com");
    Serial.println("Waiting for NTP time sync...");
    
    int retryCount = 0;
    time_t now = time(nullptr);
    while (now < 24 * 3600 && retryCount < 20) {
        delay(500);
        Serial.print(".");
        now = time(nullptr);
        retryCount++;
    }
    
    if (now < 24 * 3600) {
        Serial.println("\nNTP sync failed! Using defaults.");
    } else {
        struct tm timeInfo;
        gmtime_r(&now, &timeInfo);
        char timeStr[30];
        strftime(timeStr, sizeof(timeStr), "%Y-%m-%d %H:%M:%S", &timeInfo);
        Serial.print("\nNTP time synced: ");
        Serial.println(timeStr);
    }
}

// Check if it's time for an update considering millis() rollover
bool checkTimeForUpdate(unsigned long currentTime, unsigned long lastUpdate, unsigned long interval) {
    // Check if millis() has rolled over
    if (currentTime < lastUpdate) {
        // Calculate time elapsed considering the rollover
        return ((0xFFFFFFFF - lastUpdate) + currentTime) >= interval;
    } else {
        // Normal case, no rollover
        return (currentTime - lastUpdate) >= interval;
    }
}

// Main setup function
void setup() {
    Serial.begin(115200);
    Serial.println("\nDexcom Monitor Starting...");
    Serial.print("Free heap at start: ");
    Serial.println(ESP.getFreeHeap());
    
    // Initialize display
    tft.init();
    tft.setRotation(1); // Landscape mode
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    
    // Initialize display manager
    displayManager.init();
    displayManager.showInitialScreen();
    
    // Initialize touch screen
    touchHandler.init();
    
    // Initialize SPIFFS for storing settings
    if (!SPIFFS.begin(true)) {
        Serial.println("SPIFFS Mount Failed - Formatting");
        if (!SPIFFS.format()) {
            Serial.println("SPIFFS format failed");
        } else {
            Serial.println("SPIFFS formatted successfully");
            if (!SPIFFS.begin()) {
                Serial.println("SPIFFS mount still failed after format");
            } else {
                Serial.println("SPIFFS mounted after format");
            }
        }
    } else {
        Serial.println("SPIFFS mounted successfully");
    }
    
    // Load saved settings
    settings.load();
    
    // Set reset pin as input
    pinMode(RESET_PIN, INPUT_PULLUP);
    
    // Check if reset button is pressed during boot
    if (digitalRead(RESET_PIN) == LOW) {
        tft.fillScreen(TFT_BLACK);
        tft.setCursor(20, 60);
        tft.println("Reset button pressed");
        tft.setCursor(20, 90);
        tft.println("Resetting settings...");
        shouldResetSettings = true;
        delay(2000);
    }
    
    // Connect to WiFi
    if (!wifiHelper.connect()) {
        ESP.restart();
    }
    
    // Configure time
    tft.setCursor(20, 120);
    tft.println("Setting up NTP...");
    setupTime();
    
    // Initialize Dexcom client
    dexcomClient.init();
    
    // Verify credentials
    if (strlen(settings.dexcomUsername) == 0 || strlen(settings.dexcomPassword) == 0) {
        Serial.println("ERROR: Dexcom credentials are empty!");
        
        tft.fillScreen(TFT_BLACK);
        tft.setTextSize(2);
        tft.setTextColor(TFT_RED);
        tft.setCursor(20, 60);
        tft.println("Missing Dexcom credentials");
        tft.setCursor(20, 90);
        tft.println("Hold reset button for 5s");
        tft.setCursor(20, 120);
        tft.println("Then reconfigure settings");
        
        return;
    }
    
    // Connect to Dexcom
    tft.fillScreen(TFT_BLACK);
    tft.setTextSize(2);
    tft.setCursor(20, 60);
    tft.println("Connecting to Dexcom...");
    
    // Try authentication with retry
    if (dexcomClient.authenticateWithRetry()) {
        if (dexcomClient.login()) {
            // Initialize variables
            float current_glucose = 0;
            float previous_glucose = 0;
            char trend[20] = "";
            char timestamp[10] = "";
            unsigned long dexcomTime = 0;
            
            // Get initial glucose data
            if (dexcomClient.fetchGlucoseData(current_glucose, previous_glucose, trend, timestamp, dexcomTime)) {
                // Store the first reading
                displayManager.setGlucoseData(current_glucose, previous_glucose, trend, timestamp, dexcomTime);
            }
        }
    }
    
    Serial.print("Free heap after setup: ");
    Serial.println(ESP.getFreeHeap());
}

// Main loop function
void loop() {
    unsigned long currentTime = millis();
    
    // Handle touch input
    if (touchHandler.isTouchEnabled()) {
        bool shouldRestart = touchHandler.handleTouch(currentTime);
        
        // If reset credentials was confirmed, restart device
        if (shouldRestart) {
            ESP.restart();
        }
    }
    
    // Check if reset button is being held for 5 seconds
    if (digitalRead(RESET_PIN) == LOW) {
        unsigned long buttonPressStart = currentTime;
        while (digitalRead(RESET_PIN) == LOW && millis() - buttonPressStart < 5000) {
            delay(100);
        }
        
        // If button was held for 5 seconds
        if (millis() - buttonPressStart >= 5000) {
            tft.fillScreen(TFT_BLACK);
            tft.setCursor(20, 60);
            tft.println("Resetting settings...");
            tft.setCursor(20, 90);
            tft.println("Restarting...");
            
            // Reset WiFi settings
            WiFiManager wifiManager;
            wifiManager.resetSettings();
            
            delay(2000);
            ESP.restart();
        }
    }
    
    // Check WiFi connection every 5 minutes
    static unsigned long lastWiFiCheckTime = 0;
    if (currentTime - lastWiFiCheckTime >= 300000) { // 5 minutes
        wifiHelper.checkConnection();
        lastWiFiCheckTime = currentTime;
    }
    
    // Variables for glucose data
    static unsigned long lastUpdateTime = 0;
    static unsigned long lastCheckTime = 0;
    static unsigned long lastDexcomReadingTime = 0;
    
    // Determine if it's time to update glucose data
    bool shouldUpdate = false;
    bool isOverdueCheck = false;
    
    if (lastUpdateTime == 0) {
        // First run - always update
        shouldUpdate = true;
        Serial.println("First run, fetching initial glucose data...");
    } 
    else if (lastDexcomReadingTime > 0) {
        // We have a previous Dexcom reading timestamp
        time_t now = time(nullptr);
        unsigned long long currentEpochMillis = ((unsigned long long)now) * 1000;
        
        // Calculate time since last Dexcom reading
        unsigned long long timeSinceLastReading = currentEpochMillis - lastDexcomReadingTime;
        unsigned long secondsSinceLastReading = timeSinceLastReading / 1000;
        
        // Check if we're close to the 5-minute mark
        if ((secondsSinceLastReading >= 295 && secondsSinceLastReading <= 305) && 
            (currentTime - lastCheckTime >= 15000 || lastCheckTime == 0)) {
            shouldUpdate = true;
            lastCheckTime = currentTime;
            Serial.printf("Checking for update: Last reading was %lu seconds ago\n", secondsSinceLastReading);
        }
        
        // Fallback: Check more frequently if overdue
        if (secondsSinceLastReading > 360 && (currentTime - lastCheckTime >= 10000 || lastCheckTime == 0)) {
            shouldUpdate = true;
            isOverdueCheck = true;
            lastCheckTime = currentTime;
            Serial.printf("Backup check: Last reading was %lu seconds ago (overdue)\n", secondsSinceLastReading);
        }
    } 
    else {
        // If we don't have a Dexcom timestamp yet, check every 5 minutes
        if (checkTimeForUpdate(currentTime, lastUpdateTime, UPDATE_INTERVAL)) {
            shouldUpdate = true;
            lastCheckTime = currentTime;
            Serial.println("Checking on regular interval (no Dexcom timestamp yet)");
        }
    }
    
    // Update data if needed
    if (shouldUpdate && WiFi.status() == WL_CONNECTED) {
        // Only try if we have credentials
        if (strlen(settings.dexcomUsername) > 0 && strlen(settings.dexcomPassword) > 0) {
            float current_glucose = 0;
            float previous_glucose = 0;
            char trend[20] = "";
            char timestamp[10] = "";
            unsigned long dexcomTime = 0;
            
            // Try to fetch glucose data
            if (strlen(dexcomClient.getSessionId()) > 0) {
                if (dexcomClient.fetchGlucoseData(current_glucose, previous_glucose, trend, timestamp, dexcomTime, isOverdueCheck)) {
                    displayManager.setGlucoseData(current_glucose, previous_glucose, trend, timestamp, dexcomTime);
                    lastUpdateTime = currentTime;
                    lastDexcomReadingTime = dexcomTime;
                }
            } else if (dexcomClient.authenticateWithRetry()) {
                if (dexcomClient.login()) {
                    if (dexcomClient.fetchGlucoseData(current_glucose, previous_glucose, trend, timestamp, dexcomTime, isOverdueCheck)) {
                        displayManager.setGlucoseData(current_glucose, previous_glucose, trend, timestamp, dexcomTime);
                        lastUpdateTime = currentTime;
                        lastDexcomReadingTime = dexcomTime;
                    }
                }
            }
        }
    }
    
    // Update time display every minute
    static unsigned long lastTimeDisplayUpdate = 0;
    if (currentTime - lastTimeDisplayUpdate >= 60000) { // Every minute
        lastTimeDisplayUpdate = currentTime;
        displayManager.updateTimeDisplay();
    }
    
    // Apply pending display updates
    if (displayManager.needsFullUpdate()) {
        if (displayManager.isDisplayingSettings()) {
            displayManager.drawSettingsScreen();
            // We never want to show the time on the settings screen
            displayManager.clearTimeUpdate();
        } else if (displayManager.isDisplayingKeyboard()) {
            displayManager.drawKeyboard();
        } else if (displayManager.isDisplayingGraph()) {
            displayManager.drawGlucoseGraph();
        } else {
            displayManager.updateDisplay();
        }
        displayManager.clearFullUpdate();
        displayManager.clearTimeUpdate();
    } else if (displayManager.needsTimeUpdate() && !displayManager.isDisplayingGraph() && 
              !displayManager.isDisplayingKeyboard() && !displayManager.isDisplayingSettings()) {
        displayManager.updateTimeDisplay();
        displayManager.clearTimeUpdate();
    }
    
    delay(100); // Small delay to prevent CPU hogging
}